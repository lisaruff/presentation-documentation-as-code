= Documentation as Code: Script

// tag::title[]
Welcome everyone!
Today, we're going to look at how you can write in AsciiDoc and publish everywhere.

But, before we get there, I want to share with you my earliest memory of publishing and how it impacts my philosophy today.
// end::title[]

== Personal Story

// tag::print-shop-box[]
My first computer was an Apple II with an ImageWriter printer. Anyone remember that? It was the coolest thing I had ever seen. _And_ it included The Print Shop software!
// end::print-shop-box[]

// tag::print-shop-select[]
I went crazy making signs, banners, greeting cards and that most-important of teenage items: a "Keep Out" for my bedroom door (complete with skull and crossbones).
// end::print-shop-select[]

// tag::print-long-banner[]

Printing those signs was my first experience publishing content. What an amazing sense of power it gave me. I could write and have those words transformed into something material. Tangible.
And my words affected other people.
What a rush.

// end::print-long-banner[]

// tag::color-ribbon-cartridge[]

Now, on the practical side of things, this was not a speedy process. The printer clacked and clattered away in a flurry of action, but we're talking walk-away-and-come-back-in-an-hour actual speed. Plus, those printer ribbons were expensive and they lasted only so long. My message--my content--had to be chosen wisely for optimum effect and impact and to keep my parent's lectures about "money growing on trees" to a minimum.

// end::color-ribbon-cartridge[]

// tag::print-banner[]
I also had to share this computer with my siblings. We _all_ wanted a say, each of us wanted _our_ message published for the world to see. And, let me tell you, there's nothing more fierce than sibling competition.
So this was not only my first publishing experience, but also my first collaborative one.
// end::print-banner[]

== Introduction

// tag::many-masters[]
Technical content today is not that far removed from my childhood print shop. We must still choose our words wisely for coherence and clarity. We must work with others both in the creation of content and in making sure that content is available to the world. Seeing our work and words on the page is still just as thrilling.

//LAR: this next line doesn't make sense as a segue from the personal story to the next one about flexibility. (But I need some clarification before I can write what would make sense.)
#Our technical content today has much to say and must serve many masters, just as the content did in that childhood print shop.#

It's essential that your content workflow be flexible enough to meet these demands.

// end::many-masters[]

// tag::separate[]
The best way to ensure this flexibility is to have a separation of content and presentation (and even the infrastructure that makes the presentation possible).
That way, you're able to meet the needs of the various stakeholders.
But there's a careful balance that must be achieved to avoid hindering creation, publication, and collaboration.
It's a balance that I believe AsciiDoc strikes.

I'll explain why in this talk.
// end::separate[]

//When evaluating a content system for creating technical documentation, you should consider two questions:
//
//* What are the capabilities of the content system?
//* How do those capabilities align with your needs?

// tag::agenda[]
I believe we should consider three key capabilities when evaluating--and adopting--a content system.

. Creation
. Publication
. Collaboration

We'll evaluate AsciiDoc through the lens of these three capabilities to investigate its strengths and learn/discover how to get the most out of them.
// visual concept: show magnifying glass overlay on list
// end::agenda[]

== Creation

// tag::creation[]
I'm going to start with the writers in the room. Here's the thing: I'm on your side.

Like you, I believe content is king. I also believe that a content system that doesn't consider the needs of the author first is not sustainable. Writers need a system that allows them to do what they do best: write. But many content systems seem determined to make this simple act as difficult as possible. They are cumbersome, complicated and downright frustrating.

//LAR: dump the "docbook" slide and go right to the "docbook example" slide. BTW: I'm not going to make those changes because I'm not sure how to move things without creating a headache for you.
// end::creation[]

// tag::confined[]
Anyone recognize this?

_(DocBook example)_

// end::confined[]

// tag::docbook[]
This is DocBook, an XML schema that's highly structured and semantic with a keen focus on separating content from presentation.

// end::docbook[]



// tag::docbook-critique-a[]

As a writer, would you want to use this every day, day-in, day-out? I didn't think so.

Content is locked up in this structure. It's necessary to supplement every piece of content with an enclosure of markup since nothing is implied. There is the additional burden of having to remember all the tags and when to use them.

The ironic part is that the engineer didn't do herself much of a service either.
XML tools--especially the ones in this toolchain like XSLT--are a pain to work with.

Nobody wins here.
// end::docbook-critique-a[]

// tag::docbook-critique-b[]



// end::docbook-critique-b[]

// tag::latex[]
Now, how about this?

//LAR: drop the "latex" slide and go right to the example.
// end::latex[]

_(LaTeX example)_

// tag::latex-critique-a[]
O_o

Clearly, the engineer was having fun while the writer was away.

The message here, if you can interpret (difficult, I know) is: "`I don't see the difference between content and presentation/layout, so I'll just mix all the concerns together.`"
// end::latex-critique-a[]

// tag::latex-critique-b[]
Writers get lost in this system not only because the content is locked up in a bird nest, but now there's a deluge of dialects that no mere mortal can possibly remember.

// end::latex-critique-b[]

// tag::got-pdf[]
The other major problem is that LaTeX was not designed with multi-channel web publishing in mind. You're hamstrung before you've even begun to create.

The point here is that many content systems cater more--or even exclusively--to the technologist rather than the writer.

That has got to change, which is where Asciidoc comes in to save the day.
// end::got-pdf[]

// tag::asciidoc[]
//LAR: go right to the Asciidoc example slide.
So, how about this instead?

// end::asciidoc[]

_(AsciiDoc example)_

// tag::asciidoc-critique[]
\o/



We created Asciidoc as a writer-centric markup system.
// end::asciidoc-critique[]

// tag::asciidoc-qualities[]
//LAR: can we have a series of example slides as you go through this list of benefits? That would be more informative and engaging. I'm not wild about the highlighted list because it isn't "showing" what you're talking about, which is the point, right? Slides that show the Asciidoc version and what is created (like the reference manual) would be great.

The first thing you'll notice is that the syntax is clear & concise.
//LAR: a slide here of the syntax that shows what you mean.
What you see is predominantly content.
It's readable in raw form, unlike other formats we've seen.

//LAR: is this quote necessary? Maybe make it a slide and move it to the end of this section?
#"Perfection is achieved not when there's nothing more to add, but when there's nothing left to take away."
-- Antoine de Saint-ExubÃ©ry#

Paragraphs are just paragraphs, no bullshit.
//LAR: give me an example slide.
The remaining marks are based on familiar conventions, such as asterisks to itemize a list or equal signs to designate section titles.
//LAR: another slide example.
Words that appear in the syntax are selected from common terminology like "`source`" and "`image`".

In general, the syntax is remarkably forgiving making it less daunting.

If you dig a bit deeper, you'll notice there's a consistency to the syntax.
Indeed, the language is based on repeatable patterns and is extended by following those same patterns, which we'll get into later.

Finally, the syntax is extremely semantic.
Each bit of content belongs to a node, a content block or phrase.
These "`nodes`" can be annotated with extra bits of information that states what the content is, how it might be presented, and other properties.
// end::asciidoc-qualities[]

//LAR: from here, the slides lose me for a while. They seem to have little to do with the content of your talk, or are very thin in content/visual.

// tag::ex-roles[]
The most versatile semantic information is the role.

_(role examples)_

//LAR: you need to make this next a complete thought. The way I read it, you talk about roles and then go into line orientation. Roles don't come into it again.
#The ability to add metadata to the content not only encourages the separation of content and presentation, it also informs transformation, which we'll get into next.#
// end::ex-roles[]

// tag::left-aligned-lines[]
// QUESTION should point about line-oriented/left-align go right at beginning, before other characteristics?

One reason the syntax is simple and consistent is because it's both line-oriented and left-aligned.
Having a syntax that is aligned to the left margin helps keeps the writer rooted.
You needn't worry how many spaces are needed and content doesn't float out into the ether.
You rely on the line-oriented fences to encompass the content instead.

//LAR: you need to explain this next section better. Why is it the best, what can be inferred, what does it matter that you write that way in code? And how does this section flow into the last paragraph's ideas?
#The line-oriented aspect is the best use of the medium.
A lot can be inferred by placing content on different lines.
We do the same thing when writing code.
Each statement gets is own line, so there's no need for a trailing semicolon.#

// end::left-aligned-lines[]

// tag::ex-delimited-block[]
Take delimited blocks for instance.
You add these "`fences`" around the content.
AsciiDoc can then assume everything between those lines is content for that block.
//LAR: give me an example slide with a result in it, please.

// end::ex-delimited-block[]

// tag::wysiwyg[]

So, what is absent here?

WYSIWYG.

// end::wysiwyg[]

// tag::ygwyg[]
You don't need it.

AsciiDoc is readable in raw form, but it is also readable in a _finished_ form. Using a text writer such as Atom with the appropriate add-ons, you can see the final product in a preview pane. You can change, embellish or restructure the entire document and see what the end result will be, right there on the screen.

(If there's time: Discuss authoring in Atom with the AsciiDoc add-on to get helpful syntax highlighting.
Also mention AsciidocFX and IntelliJ IDEA.)
// end::ygwyg[]

// tag::ide-for-writers[]
//LAR: This next seems like a non sequitur.
#In fact, I continue to advocate for the development of an IDE for writers.#

// end::ide-for-writers[]

// tag::atom[]

// end::atom[]

// tag::creation-recommended-practices[]

Asciidoc has many, many, _many_ options built into it and just as many ways to control your content.

Many shops tend to standardize on a cross section for consistency. Dialects are put in place to reinforce the impression of simplicity. Templates for common document types are set up to ensure consistency and to allow the writers to jump in and write.

Some other ways Asciidoc is used for writing include partitioning documents, such as splitting up a book into chapters. You can include shared content or extract code samples so that they don't get mixed up in content.
AsciiDoc supports all this through it's include mechanism.
It even goes so far as to allow you to include fragments of another document by line number or tagged region.

//LAR: this next section needs to be smoothed into a more linear progression and probably cut some, but I'm not strong enough in Asciidoc to do it myself. Make sure it speaks to the writer, because that's who has been the focus in this section. Or bring up engineering.
#One way this feature is used is to make testable documentation.
Code snippets can be pulled in from a test suite, where the code can be tested in isolation.
It's also just nice to get all your code samples out of the writer's hair.
Since includes can span repository boundaries and even be fetched from a URL, you can achieve a "`single source of truth`" (instead of copy/paste)
AsciiDoc's attributes are another way to inject dynamic or reusable content into the document.
Of course, once you start dividing up your document, you'll want to be able to create references between them.
AsciiDoc supports both internal and inter-document references, and there are ways to extend this capability.#
// TODO Recommend checking out the AsciiDoc Syntax Quick Reference and Awesome Asciidoctor.
// end::creation-recommended-practices[]

// tag::migration[]

I am not going to get into migrating your existing content into Asciidoctor today, but be aware that it is more than doable. There are conversion tools, and many others have made the switch successfully. See me afterward and I can give you some pointers.

// end::migration[]

// tag::dawn[]
So far we've just talked about the source, the domain of the writer.
Now that you have your content in AsciiDoc, what can you do with it?
This is where the engineer comes in.

The AsciiDoc syntax is so simple and elegant, it's easy to be deceived that it can only produce primitive output.
You couldn't be more mistaken.
The AsciiDoc content is just the raw material, its semantics the seeds of the blossoms that we'll produce.
Let's shed some light on how we can transform it and where we can publish it.

It's the dawn of endless possibilities, just like The Print Shop was for me as a kid.
// end::dawn[]

== Publication

// tag::publication[]
The focus of this section is the AsciiDoc processor & publisher, Asciidoctor.
Engineers, wake up, this is for you.
// end::publication[]

// tag::asciidoc-vs-asciidoctor[]
AsciiDoc is the language. +
Asciidoctor is the processor.
// end::asciidoc-vs-asciidoctor[]

// tag::conversion[]
I want to start by mentioning that, out of the box, Asciidoctor can convert to HTML and DocBook, allowing you to preview and export the content, respectively.
This is just the default interpretation of the AsciiDoc source.
There's nothing stopping you from interpreting the source in a different way.
That's what separation of content and presentation affords you.
Every bit of output that gets generated can be customized in one way or another.
You should look at the AsciiDoc source as a source of record, not a textual representation of the output.
// end::conversion[]

// tag::ex-extensions[]
I'll cite a few examples to get you thinking about what is possible.

* tabs
* background image for slide
* import PDF page
* slide notes
// end::ex-extensions[]
//LAR: it would be good to have slide examples of these. 
// tag::ast[]
What we're talking about here is transformation.
Transformation is the key to being able to publish to multiple channels in a variety of formats.

When Asciidoctor reads the file, it builds an AST, or abstract syntax tree.
That tree is passed to a converter, which then transforms it into the target format, such as HTML.

One way to extend Asciidoctor is to write a custom converter, or build on one that already exists.
The only limit to what output formats you can produce is what you're willing/able to create.

But even before the tree is sent to the converter, you have a chance to manipulate it or mine it for information.
In fact, you don't even need to output anything.
You can just use the AST to query the document for information in a contextual way (unlike grep, which is crude and blind to context)

You can even go one step further and tap into the parser itself.
Asciidoctor provides an extension API to allow you to add additional elements to the syntax, such as a custom block or macro.
This stuff literally makes me giddy.
// end::ast[]

// tag::aggregate[]
As you can see, you have a lot of control over how the AsciiDoc is interpreted.
Be careful not to fall into the trap of thinking that one input document produces one output document.
For example, you could take one input document that represents a book and produce multiple pages of HTML. Simple enough.
Or, you could use the processor, or a toolchain that wraps it, that takes input from several sources and weave them together.
Where we see this technique used is in API documentation tools like Spring REST Docs and swagger2markup, which generate AsciiDoc to document the API methods, then combine it with content written by the author and produces a document (or documents) to be published.
Part generated, part scribed.
The toolchain plays the role of orchestrator, weaving together disparate content sources.
// end::aggregate[]

// tag::endless-possibilities[]
There truly are endless possibilities for your content once in this format and managed by this toolchain.
This transformation capability also keeps you from being tied down.
Just as you can generate formats for publishing, you can generate to another source format, even AsciiDoc.
If you store the source in a version control system, which we'll talk more about in the next section, the publication tool can even tap into the document history and inject content such as an audit log or make different versions of the document available.
This is another powerful way to keep your content DRY and free from doing tasks for information that can be implied.
//You could extend the abstraction even further and avoid coupling the path of the source file with the output path.
//Instead, give each document a business ID so you can move files around and still produce the same output structure.
// end::endless-possibilities[]

// tag::push-to-publish[]
Last but not least, publication should be fully managed by an automated build.
It doesn't end with Asciidoctor.
The build should not only handle converting the content and publishing it to the various channels, but should describe and manage the infrastructure as well.
Treat your docs just like you would any other application.
It should be possible to "`push to publish`" and the computer takes over from there.
These automated builds also aid with collaboration, which we'll get into next.
// end::push-to-publish[]

// tag::publish-everywhere[]
// TODO
// end::publish-everywhere[]

// tag::publication-recommended-practices[]
// TODO
// end::publication-recommended-practices[]

== Collaboration

// tag::collaboration[]
Now we have arrived at the final section of this talk: collaboration. Where it all comes together to make a perfect world.

AsciiDoc lends itself very well to collaboration because many of the tools we need for that collaboration are already in place.
While there's a bit more assembly required up front, what you'll likely find is that it blows any proprietary, closed system out of the water.

This section addresses both the writers and the engineers, and anyone else involved in the content effort.
No doubt what makes AsciiDoc ripe for collaboration above all else is that it is version-control friendly.
AsciiDoc doesn't have "`source control support,`" rather it just lends itself to being source controlled.
No binary blobs, just plain text.
And version-control systems love plain text.
You get history, source diffs, rich diffs, branching, merging, etc., all which can be managed with interfaces like GitHub and GitLab.
// end::collaboration[]

//LAR: The next quote isn't necessarily part of the script. Let it stand as a slide.
// tag::redhat-endorsement[]
And this is a real force for contribution, as the JBoss BxMS and OpenShit teams have both observed:

> The OpenShift team reported that after the migration from DocBook to AsciiDoc, the rate of both internal and external contributions skyrocketed--from several a year to several a week. ...
>
> ...{sp}Mere days after our migration, we started seeing incoming Merge Requests, where there were none before.
> Preliminary results hint that this is an observable trend.
> -- JBoss BxMS Engineering Team
// end::redhat-endorsement[]

// tag::edit-on-github[]
Nothing drives that more, invites participation more, than the "`Edit on GitHub`" link.
It's impossible to overstate the significance of GitHub (and, increasingly, GitLab).
These interfaces have proven to be incredibly approachable and encourage contribution.
You can benefit from that phenomenon by moving your documentation there.

//LAR: What you are speaking about which is generally Asciidoc and specifically how to collaborate with/in Asciidoc. What necessary message are you trying to impart here?

I do strongly recommend investing in git training for your team. Everyone needs to understand how the "`Edit on GitHub`" process actually works and know how to manage the git workflow.
Knowing how to use git correctly will save time and toes.
// end::edit-on-github[]

// tag::asciidoc-github-support[]

// end::asciidoc-github-support[]

// tag::docs-as-code[]
All this leads to a strong-held belief of ours.
Docs = Code.
We have a long history in this industry of collaborating on code.
If we view documentation as just another form of code, we can use code collaboration processes, practices, techniques, and tools to benefit our documentation. Strength building on strength for a solid end product.
// end::docs-as-code[]

// tag::code-review[]
One of the first tools that comes to mind is code review.
Countless CMS tools have tried to manufacture a content review workflow.
Well, we have one right here, (built on an accepted industry practice), supported by incredible code review tools like Gerrit, GitHub, GitLab, and so forth.

This system is also makes it easy for managers to monitor the workflow, to determine what changed or what work was done, simply by looking at the git history or activity charts on GitHub and GitLab.
// end::code-review[]

// FIXME missing slides for the following part of the script
////
Given that AsciiDoc is just plain text, like developers, writers can use their own tools in their own writing environment.
No need for special, proprietary, foreign, costly tools.
In fact, you really should avoid imposing tool/editor choices.
You can work in isolation, then just push to publish.
Why is this important?
"`Happy people collaborate well`" (or are more inclined to).
How do you coordinate efforts?
Use an issue tracker to manage bugs, improvements, and content initiatives.
You can then see content progress as it moves across the issue board.
<figure:issue board>
Mention the issue when submitting the pull request that resolves it.
Just like code.
<figure:git history>
////

// tag::collaboration-recommended-practices[]

Although AsciiDoc is naturally friendly to version-control systems, there are ways to organize the content that let you get even more out of it.

//LAR: I think this next could be cut. It's too specific and "git-tutorial" for what you are addressing in this script.
#For instance, I highly recommend writing with a sentence-per-line style.
By doing so, you isolate changes to the line of content that they affect, much like changing a line of code.
If you use fixed-column hard-wrapping, the change at the beginning of a paragraph can have a cascading effect, possibly interfering with unrelated lines that someone else is modifying.
In general, you want to look for ways that allow you to work in different parts of a file without causing conflicts.
Isolate your changes.#

Another way to avoid such conflicts is to use well-factored, modular content.
You want a consistent, intuitive, and discoverable structure.
Consider using the topic-based authoring method so the content can be stored separately from the files that aggregate it.
As mentioned before, import non-content such as code snippets from the original source file (possibly even in a separate repository) so that it can be managed independently and doesn't fall out of date.
// TODO mention git lfs

//LAR: This next is a style-guide issue, not so much collaboration; how you use Asciidoctor within Git, not how a team collaborates to use Asciidcotor. It might be germane, but not in this section.
#It's best to have a style guide: for syntax; for structure; for patterns; for voice.
Automate the human process.
This reduces the amount of thought, avoids errors, and drastically cuts down on expensive micro-migrations to fix mistakes.
Again, the document templates mentioned earlier benefit collaboration as well.#

Validation tools are also important because they help ensure quality and consistency.
You can tap into the Asciidoctor process to perform validations in addition to the ones that come out of the box.
//LAR: this is a repeat of the publication section on splitting out content blocks.
#Don't fall into the trap of putting all your content in a single repository.
Instead, organize your repositories by software product or logical product group.
We can refer to this repository as a "`content container.`" (a contrast to a "`library layout`" where there's one directory per book)
You can then assume that all the content in a single repository is versioned together.
If different documents have different versioning schemes, or move at different rates, that's an indicator you should move them to separate repositories.
Also avoid creating monolithic documents.
In particular, beware of the Russian Doll Effect (contributing guide inside developer guide inside of README).
It's easy to create a script that brings them all back together.#

#The reason this partitioning is important is because it enables you to leverage branches properly.
Have a branch for each major release line.
Different major (and maybe even minor) versions of the document should be stored in separate branches.
Don't use different directories to store the versions, as I've seen some teams do.
You lose a lot of capabilities of the version control system by not using branches because the commands for those systems don't understand how to compare documents that way.
It's also much harder to search for content.#

//LAR: Back to Asciidoctor for a moment, but what has this to do with collaboration?
#Take a look at AsciiBinder for an example of a build system that builds out versions of the documentation from the branches.
Regardless of what structure you choose, anyone should be able to build the output through a simple interface, without having to remember complex commands.
That's why it's important to have an automated build, which obviously benefits publication as discussed earlier.#
// end::collaboration-recommended-practices[]


As you can see, Adciidoc allows you to set up many ways to collaborate, bringing all the voices and talents together in one place to make strong, coherent documentation.
//(See https://www.youtube.com/watch?v=JvRd7MmAxPw&list=PLZAeFn6dfHpnN8fXXHwPtPY33aLGGhYLJ&index=20)

== Conclusion

// tag::recap[]
Today, we have evaluated AsciiDoc through the lens of three capabilities: creation; publication; and collaboration. In every case, Asciidoc has shown how it can help create a robust content system.

Writers can write with minimal interference from over-blown markups and unnecessary structure. They can focus on the words, the ideas and the messages that reach out to millions of users across the globe, or just to the person in the next cubicle.

Engineers are empowered as well. In Asciidoc, every bit of output that gets generated can be customized in one way or another for their needs. Because content that is locked away cannot serve its function, cannot reach its users across channels.

Finally, both writers and engineers--as well as anyone else involved in the end product--can collaborate in a systematic, stream-lined way that eliminates duplicated effort or duplicated headaches. Like the technology that it documents, technical writing benefits from many eyes and minds.
Anything inherently complex does.
Asciidoc helps that collaboration, encouraging contributions that make good content great.


The Asciidoctor toolchain, from the AsciiDoc language to the Asciidoctor processor, extensions, converters, and tools, brings all these ideas into one.

These capabilities happen to be the three pillars of the Asciidoctor project, so we expect the story to only get better.
// tag::recap[]

// tag::fin[]
//Write in AsciiDoc, publish everywhere!

Thank you!
// end::fin[]
